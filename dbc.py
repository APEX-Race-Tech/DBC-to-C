import sys
import os
import cantools
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QFileDialog, QTextEdit, QLabel, QStatusBar, QMessageBox,
    QSplitter
)
from PyQt5.QtGui import QFont, QSyntaxHighlighter, QTextCharFormat, QColor, QIcon
from PyQt5.QtCore import Qt, QUrl
from PyQt5.QtGui import QFont, QSyntaxHighlighter, QTextCharFormat, QColor, QIcon, QPixmap, QCursor, QPainter
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QFileDialog, QTextEdit, QLabel, QStatusBar, QMessageBox,
    QSplitter, QDialog
)
from PyQt5.QtCore import pyqtSignal

# --- C Syntax Highlighting (A simple version for portability) ---
class CppHighlighter(QSyntaxHighlighter):
    def __init__(self, parent):
        super().__init__(parent)
        self.highlighting_rules = []

        # Keywords
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor("#569CD6"))
        keyword_format.setFontWeight(QFont.Bold)
        keywords = [
            "\\bchar\\b", "\\bclass\\b", "\\bconst\\b", "\\bdouble\\b", "\\benum\\b",
            "\\bfloat\\b", "\\bint\\b", "\\blong\\b", "\\bshort\\b", "\\bsigned\\b",
            "\\bstruct\\b", "\\btypedef\\b", "\\bunion\\b", "\\bunsigned\\b", "\\bvoid\\b",
            "\\bvolatile\\b", "\\bif\\b", "\\belse\\b", "\\bfor\\b", "\\bwhile\\b",
            "\\breturn\\b", "\\bcase\\b", "\\bswitch\\b", "\\bbreak\\b", "\\bcontinue\\b",
            "\\bstatic\\b", "\\bextern\\b"
        ]
        for word in keywords:
            self.highlighting_rules.append((f"\\b{word}\\b", keyword_format))

        # Types (like uint8_t)
        type_format = QTextCharFormat()
        type_format.setForeground(QColor("#4EC9B0"))
        types = ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
        for t in types:
            self.highlighting_rules.append((f"\\b{t}\\b", type_format))

        # Preprocessor directives
        preprocessor_format = QTextCharFormat()
        preprocessor_format.setForeground(QColor("#C586C0"))
        self.highlighting_rules.append(("#[^\n]*", preprocessor_format))
        
        # Comments
        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor("#6A9955"))
        self.highlighting_rules.append(("//[^\n]*", comment_format))

    def highlightBlock(self, text):
        for pattern, format in self.highlighting_rules:
            for match in __import__("re").finditer(pattern, text):
                self.setFormat(match.start(), match.end() - match.start(), format)

# --- C Code Generation Logic ---
def _get_c_type(signal):
    if signal.scale != 1 or signal.offset != 0: 
        return "float"
    if signal.is_signed:
        if signal.length <= 8: 
            return "int8_t"
        if signal.length <= 16: 
            return "int16_t"
        if signal.length <= 32: 
            return "int32_t"
        return "int64_t"
    else:
        if signal.length <= 8: 
            return "uint8_t"
        if signal.length <= 16: 
            return "uint16_t"
        if signal.length <= 32: 
            return "uint32_t"
        return "uint64_t"

def generate_header_code(db):
    code = [
        "// Auto-generated by ART_DBC-Code-Generator\n",
        "#ifndef CAN_MESSAGES_H",
        "#define CAN_MESSAGES_H\n",
        "#include <stdint.h>\n"
    ]
    
    for msg in db.messages:
        code.append(f"// Message: {msg.name} (ID: 0x{msg.frame_id:X})")
        code.append(f"typedef struct {{")
        for sig in msg.signals: 
            # Add scaling information in comments
            scale_info = ""
            if sig.scale != 1 or sig.offset != 0:
                scale_info = f" // scale={sig.scale}, offset={sig.offset}"
            code.append(f"    {_get_c_type(sig)} {sig.name};{scale_info}")
        code.append(f"}} {msg.name}_t;\n")
        code.append(f"void unpack_{msg.name}(const uint8_t* data, {msg.name}_t* msg);")
        code.append(f"void pack_{msg.name}(const {msg.name}_t* msg, uint8_t* data);\n")
    
    code.append("#endif // CAN_MESSAGES_H")
    return "\n".join(code)

def generate_source_code(db):
    code = [
        '// Auto-generated by ART_DBC-Code-Generator\n',
        '#include "can_messages.h"',
        '#include <string.h> // For memcpy\n'
    ]
    
    for msg in db.messages:
        code.append(f"void unpack_{msg.name}(const uint8_t* data, {msg.name}_t* msg) {{")
        code.append(f"    uint64_t raw_data = 0; memcpy(&raw_data, data, {msg.length});\n")
        
        for sig in msg.signals:
            mask, start_bit = (1 << sig.length) - 1, sig.start
            code.append(f"    uint64_t raw_{sig.name} = (raw_data >> {start_bit}) & 0x{mask:X}ULL;")
            
            if sig.is_signed and sig.length < 64:
                sign_bit_mask = 1 << (sig.length - 1)
                # Generate the extension mask as a proper C bit mask
                # This creates a mask like 0xFFFFFF00 for an 8-bit signal
                extension_mask = ((1 << 64) - 1) & ~((1 << sig.length) - 1)
                code.append(f"    if (raw_{sig.name} & 0x{sign_bit_mask:X}ULL) {{ raw_{sig.name} |= 0x{extension_mask:X}ULL; }}")
            
            c_type = _get_c_type(sig)
            if c_type == "float": 
                code.append(f"    // Apply scaling: raw_value * {sig.scale} + {sig.offset}")
                code.append(f"    msg->{sig.name} = (float)raw_{sig.name} * {sig.scale} + {sig.offset};")
            else: 
                code.append(f"    // No scaling applied (raw value)")
                code.append(f"    msg->{sig.name} = ({c_type})raw_{sig.name};")
        
        code.append("}\n")
        
        code.append(f"void pack_{msg.name}(const {msg.name}_t* msg, uint8_t* data) {{")
        code.append("    uint64_t raw_data = 0;\n")
        
        for sig in msg.signals:
            c_type = _get_c_type(sig)
            if c_type == "float": 
                code.append(f"    uint64_t raw_{sig.name} = (uint64_t)((msg->{sig.name} - ({sig.offset})) / {sig.scale});")
            else: 
                code.append(f"    uint64_t raw_{sig.name} = (uint64_t)msg->{sig.name};")
            
            mask, start_bit = (1 << sig.length) - 1, sig.start
            code.append(f"    raw_data |= (raw_{sig.name} & 0x{mask:X}ULL) << {start_bit};")
        
        code.append(f"\n    memcpy(data, &raw_data, {msg.length});")
        code.append("}\n")
    
    return "\n".join(code)

# --- Main Application UI ---
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("DBC to C Code Generator")
        self.setGeometry(100, 100, 900, 700)
        self.db = None
        
        # Set the application icon
        icon_path = "apex_orange_ONLY LOGO.png"
        if os.path.exists(icon_path):
            try:
                # Create properly sized icon to prevent stretching
                icon_pixmap = QPixmap(icon_path)
                if not icon_pixmap.isNull():
                    # Create a 32x32 canvas with transparent background
                    canvas = QPixmap(32, 32)
                    canvas.fill(Qt.transparent)
                    
                    # Scale the logo maintaining aspect ratio
                    scaled_logo = icon_pixmap.scaled(32, 32, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    
                    # Calculate center position
                    x = (32 - scaled_logo.width()) // 2
                    y = (32 - scaled_logo.height()) // 2
                    
                    # Paint the scaled logo onto the canvas
                    painter = QPainter(canvas)
                    painter.drawPixmap(x, y, scaled_logo)
                    painter.end()
                    
                    self.setWindowIcon(QIcon(canvas))
                else:
                    print("Warning: Could not load icon pixmap")
            except Exception as e:
                print(f"Warning: Could not load icon: {e}")
        else:
            print(f"Warning: Icon file not found: {icon_path}")
        
        # --- Main Layout ---
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        
        # --- Top Controls ---
        controls_layout = QHBoxLayout()
        self.btn_select = QPushButton("1. Select DBC File")
        self.btn_generate = QPushButton("2. Generate Code")
        self.btn_generate.setEnabled(False)
        self.btn_save = QPushButton("3. Save Files...")
        self.btn_save.setEnabled(False)
        self.btn_debug = QPushButton("Debug DBC")
        self.btn_debug.setEnabled(False)
        
        controls_layout.addWidget(self.btn_select)
        controls_layout.addWidget(self.btn_generate)
        controls_layout.addWidget(self.btn_save)
        controls_layout.addWidget(self.btn_debug)
        self.layout.addLayout(controls_layout)
        
        # --- Code Display using a Splitter ---
        splitter = QSplitter(Qt.Vertical)
        
        # Header file display
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.addWidget(QLabel("can_messages.h"))
        self.txt_header = QTextEdit()
        self.txt_header.setFont(QFont("Consolas", 10))
        self.highlighter_h = CppHighlighter(self.txt_header.document())
        header_layout.addWidget(self.txt_header)
        splitter.addWidget(header_widget)
        
        # Source file display
        source_widget = QWidget()
        source_layout = QVBoxLayout(source_widget)
        source_layout.setContentsMargins(0, 0, 0, 0)
        source_layout.addWidget(QLabel("can_messages.c"))
        self.txt_source = QTextEdit()
        self.txt_source.setFont(QFont("Consolas", 10))
        self.highlighter_c = CppHighlighter(self.txt_source.document())
        source_layout.addWidget(self.txt_source)
        splitter.addWidget(source_widget)
        
        splitter.setSizes([300, 400])  # Set initial size ratio
        self.layout.addWidget(splitter)
        
        # --- Bottom Logo Section ---
        logo_layout = QHBoxLayout()
        logo_layout.setContentsMargins(0, 2, 8, 2)  # Left, Top, Right, Bottom margins - reduced
        logo_layout.addStretch()  # Left spacing - pushes logo to right
        
        # Create clickable logo label
        self.logo_label = QLabel()
        logo_pixmap = QPixmap("apex_orange_ONLY LOGO.png")
        if not logo_pixmap.isNull():
            # Scale logo to larger size (max 45px height)
            scaled_pixmap = logo_pixmap.scaled(45, 45, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.logo_label.setPixmap(scaled_pixmap)
            self.logo_label.setCursor(QCursor(Qt.PointingHandCursor))
            self.logo_label.setToolTip("Click to visit Apex Race Tech")
            self.logo_label.mousePressEvent = self.open_website
        else:
            self.logo_label.setText("ART")
            self.logo_label.setStyleSheet("font-size: 18px; font-weight: bold; color: #FF6600;")
        
        logo_layout.addWidget(self.logo_label)
        self.layout.addLayout(logo_layout)
        
        # --- Status Bar ---
        self.setStatusBar(QStatusBar())
        
        # --- Connect Signals ---
        self.btn_select.clicked.connect(self.select_dbc_file)
        self.btn_generate.clicked.connect(self.generate_code)
        self.btn_save.clicked.connect(self.save_files)
        self.btn_debug.clicked.connect(self.debug_dbc)
        
        self.apply_stylesheet()

    def open_website(self, event):
        """Open Apex Race Tech website when logo is clicked."""
        try:
            from PyQt5.QtCore import QUrl
            from PyQt5.QtGui import QDesktopServices
            QDesktopServices.openUrl(QUrl("https://apexracetech.in/"))
        except ImportError:
            import webbrowser
            webbrowser.open("https://apexracetech.in/")

    def debug_dbc(self):
        """Display debugging information about the loaded DBC file."""
        if not self.db:
            QMessageBox.warning(self, "Warning", "No DBC file loaded. Please select a DBC file first.")
            return
        
        try:
            debug_info = []
            debug_info.append(f"Database Name: {self.db.name}")
            debug_info.append(f"Version: {self.db.version}")
            debug_info.append(f"Number of Messages: {len(self.db.messages)}")
            debug_info.append(f"Number of Nodes: {len(self.db.nodes)}")
            debug_info.append(f"Number of Signals: {sum(len(msg.signals) for msg in self.db.messages)}")
            
            # Add message details
            debug_info.append("\nMessage Details:")
            for i, msg in enumerate(self.db.messages[:10]):  # Show first 10 messages
                debug_info.append(f"  {i+1}. {msg.name} (ID: 0x{msg.frame_id:03X}) - {len(msg.signals)} signals")
                if len(msg.signals) > 0:
                    debug_info.append(f"     Signals: {', '.join(sig.name for sig in msg.signals[:5])}")
                    if len(msg.signals) > 5:
                        debug_info.append(f"     ... and {len(msg.signals) - 5} more")
            
            if len(self.db.messages) > 10:
                debug_info.append(f"  ... and {len(self.db.messages) - 10} more messages")
            
            # Add node details
            if self.db.nodes:
                debug_info.append(f"\nNodes: {', '.join(self.db.nodes)}")
            
            debug_text = "\n".join(debug_info)
            
            # Create a dialog to display the debug information
            dialog = QDialog(self)
            dialog.setWindowTitle("DBC Debug Information")
            dialog.setModal(True)
            dialog.resize(600, 500)
            
            layout = QVBoxLayout(dialog)
            
            # Add a text area for the debug info
            text_area = QTextEdit()
            text_area.setPlainText(debug_text)
            text_area.setFont(QFont("Consolas", 9))
            text_area.setReadOnly(True)
            layout.addWidget(text_area)
            
            # Add close button
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.accept)
            layout.addWidget(close_btn)
            
            dialog.exec_()
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to generate debug information:\n{e}")

    def apply_stylesheet(self):
        self.setStyleSheet("""
            QMainWindow { 
                background-color: #2b2b2b; 
                border-radius: 12px;
            }
            QWidget { 
                background-color: #2b2b2b; 
                color: #f0f0f0; 
                font-size: 10pt; 
            }
            QLabel { 
                font-weight: bold; 
                border-radius: 8px;
            }
            QPushButton { 
                background-color: #4a4a4a; 
                padding: 8px; 
                border-radius: 8px; 
                border: none;
            }
            QPushButton:hover { 
                background-color: #5a5a5a; 
                border-radius: 8px;
            }
            QPushButton:disabled { 
                background-color: #333; 
                color: #777; 
                border-radius: 8px;
            }
            QTextEdit { 
                background-color: #1e1e1e; 
                border: 1px solid #444; 
                border-radius: 8px;
                padding: 8px;
            }
            QStatusBar { 
                color: #bbbbbb; 
                border-radius: 8px;
            }
            QSplitter::handle {
                background-color: #444;
                border-radius: 4px;
            }
            QSplitter::handle:hover {
                background-color: #555;
            }
        """)

    def select_dbc_file(self):
        path, _ = QFileDialog.getOpenFileName(
            self, "Select DBC File", "", "DBC Files (*.dbc);;All Files (*)")
        if not path: 
            return
        
        try:
            self.db = cantools.database.load_file(path)
            self.statusBar().showMessage(f"Loaded '{os.path.basename(path)}'", 5000)
            self.btn_generate.setEnabled(True)
            self.btn_debug.setEnabled(True)
            self.txt_header.clear()
            self.txt_source.clear()
            self.btn_save.setEnabled(False)
            QMessageBox.information(
                self, "Success", 
                f"Successfully loaded and parsed '{os.path.basename(path)}'.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to parse DBC file:\n{e}")
            self.db = None
            self.btn_generate.setEnabled(False)
            self.btn_debug.setEnabled(False)
            
    def generate_code(self):
        if not self.db: 
            return
        self.txt_header.setPlainText(generate_header_code(self.db))
        self.txt_source.setPlainText(generate_source_code(self.db))
        self.btn_save.setEnabled(True)
        self.statusBar().showMessage("C code generated successfully.", 3000)
        
    def save_files(self):
        dir_path = QFileDialog.getExistingDirectory(
            self, "Select Folder to Save C Files")
        if not dir_path: 
            return
        
        try:
            with open(os.path.join(dir_path, "can_messages.h"), "w", encoding='utf-8') as f:
                f.write(self.txt_header.toPlainText())
            with open(os.path.join(dir_path, "can_messages.c"), "w", encoding='utf-8') as f:
                f.write(self.txt_source.toPlainText())
            QMessageBox.information(
                self, "Success", 
                f"Files saved successfully in:\n{dir_path}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save files:\n{e}")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())